cat .git/config - выводит содержимое файла

cat ~/.gitconfig - email, name

git config --global core.editor notepad - вызов блокнота, для записи коммита

git config --global core.editor - просмотр выбранного блокнота для коммита

git config alias.c '!git ...; git ...' - несколько комманд в алиасе

git config alias.c '--global' - одна комманда в алиасе

git config --global alias.coma '!git add -A;git commit' - новая команда git coma

git config --list - вывести настройки

git config --global core.excludesFile ~/.gitignore - настроить глобальный gitignore в git

notepad ~/.gitignore - открыть и создать .gitignore с помощью блокнота

git rm -r src - удаление директории src

git rm ggg.txt - удаление файла (не удалит если в файле есть изменения)

git rm -f -r src - удаление с игнорированием предупреждений

-f - игнорирование предупреждений(--force)

git rm -r --cached src - удаление директории из индекса

--cached - можно испольсзовать с разными коммандами(операция с индексом)

git mv first.html first2.html - переименование first.html


less - листалка в терминале

/editor - поиск в тексте "editor"

n - поиск вперёд

shift + n - поиск назад


git log - посмотреть список коммитов ветки
git log --medium

git log --oneline - список коммитов ветки компактнее

git log testf - коммиты ветки testf

git reflog - посмотреть лог HEAD
git log --oneline -g - то же самое

git log --pretty=format:'%h %cd  | %s %d [%an]' - сложный лог, % можно посмотреть в git help log

git log --pretty=format:'%h %cr  | %s %d [%an]' - дата от текущей до коммита(%cr)

git log --pretty=format:'%h %cd | %s %d [%an]' --date=format:'%F %R' - норм лог

git log --pretty=medium - log стандартный


git config --global pretty.my format:'%C(#f3f89d)%h %C(#418d61)%cd %C(reset)|%C(#F78972)%d %C(#9aedf1)%s' -
крутой лог с цветами, установили на my

git config --global pretty.my2 format:'%C(#f3f89d)%h %C(#418d61)%cd %C(reset)|%C(#F78972)%d %C(#9aedf1)%s %an' -
крутой лог с цветами, установили на my2 + имя автора

git log --pretty=my - вывод лога my

git config --global format.pretty my - установка лога my по умолчанию


git log master - коммиты master

git log --graph - коммиты с ветками графически

git log --oneline --graph --all - показать все ветки + связи между ними

git log ficha ^master - коммиты ветки ficha без ветки master

git log master..ficha - ветка ficha с момента отхождения от master

git log --oneline src/ggg.txt - коммиты где менялся файл

git log --oneline -p src/ggg.txt - коммиты где менялся файл + какие изменения

git log --oneline -p --follow src/ggg.txt - коммиты где менялся файл + какие изменения +
если файл был переименован, найдёт все коммиты файла

git log --oneline --grep epta - поиск коммитов в описании которых присутствует epta, из ветки HEAD

git log --oneline --grep epta master - поиск коммитов в описании которых присутствует epta, из ветки master

git log --oneline --grep epta --grep 1 master - коммиты в описании или epta или 1

git log --oneline --grep epta --grep 1 master --all-match - коммиты в описании epta и 1

git blame src/ggg.txt - вывод тех кто изменял файл

git reflog --date=iso - вывод коммитов HEAD с датой

git update-index --chmod=+x <file.name> - изменение прав исполнимости файла в индексе(для unix)

git add --chmod=+x <file.name> - изменение прав исполнимости файла не добавленного в index (для unix)

git show - посмотреть текущий коммит

git show 293ada3e4a70604ccc2c833e5b7ecc4300f525b8 - посмотреть коммит

git show testf - посмотреть HEAD коммит ветки testf

git show HEAD~ - посмотреть предыдущий коммит от HEAD

git show HEAD~~ - посмотреть пред-предыдущий коммит от HEAD

git show HEAD~~ --quiet - посмотреть пред-предыдущий коммит от HEAD краткая форма

git show HEAD~3 --quiet - посмотреть третий коммит от HEAD
git show @~3 - то же самое, HEAD = @

git show master~3 - посмотреть третий коммит от HEAD в ветке master

git show 5dadddcd~3 - посмотреть третий коммит от коммита

git show 5dadddcd:redactor/rrr.txt - посмотреть файл в коммите

git show :redactor/rrr.txt - посмотреть файл в индексе, текущей разработки

git show :/ficha1 - поиск коммита по ключевому слову

git show --pretty=fuller - посмотреть больше инф о коммите

git init - Позволяет проинициализировать репозиторий в текущей папке

git status - Показывает текущий статус

git restore --staged redactor - откатить добавление в git(index) всех файлов из папки redactor

git add - Отслеживает изменения файлов

git add --force redactor/rrr.txt - добавить файл из .gitignore

git add index.html — добавляет index.html

git add . — добавляет все файлы в индекс, текущей директории!

git add -A - индексирует все изменения, с корня проекта

git add -p src/fff.txt - добавить в индекс только выбранные изменения в файле fff.txt

git reset redactor/rrr.txt - удалить файл из индекса, только для файлов которые
отслеживаются git

git reset --hard - отменяет изменения
git reset --hard HEAD

git reset --hard @~ - передвигает HEAD текущей ветки на указанный коммит, удаляет коммит,
информация о коммите содержится в файле ORIG_HEAD, logs\HEAD, git reflog

git reset --soft @~ - передвигает HEAD текущей ветки на указанный коммит,
в момент до совершения коммита, со всеми изменениями добавленными в индекс

git reset --mixed @~ - передвигает HEAD текущей ветки на указанный коммит,
в момент до совершения коммита, изменения НЕ добавленны в индекс, но есть в рабочей директории
git reset @~ (по умолчанию)

git reset bd4f7852 src/ggg.txt - добавляет только в индекс файл из коммита

git clean -f src/ggg2.txt - очистить рабочую область от файла который не отслеживается git

git clean -f - очистить рабочую область от файлов которые не отслеживаются git

git clean -fd - очистить от папок и файлов которые не отслеживаются git

git clean -fdx - очистить файлы, папки которые не отслеживаются git и
добавлены в .gitignore

git commit - сохранение в репозиторий, с вызовом текстового редактора

git commit -v - коммит, в открытом редакторе будет информация о вносимых изменениях,
как при вызове git diff --cached

git commit -m 'commit message' — создает коммит с сообщением

git commit --all -m epta8 - индекс и коммит всех изменений для файлов, которые уже отслеживаются git
git commit -am epta9 - то же самое

git commit -m 'epta9' command.txt - коммит файла command.txt, которые уже отслеживаются git

git commit -C ORIG_HEAD - коммит с описанием другого коммита(из ORIG_HEAD),
также будет скопирована дата и имя автора коммита

git commit -C ORIG_HEAD --reset-author - коммит с описанием другого коммита(из ORIG_HEAD),
автор и дата скопированы не будут, а в коммит сохранятся реальный автор и дата

git commit -с ORIG_HEAD - коммит с описание другого коммита(из ORIG_HEAD), с вызовом редактора
для редактирования описания коммита

git commit --amend - замена текущего коммита на новый коммит, на место текущего,
исправление текущего коммита. Будут скопированы автор и дата коммита.

git commit --amend --reset-author - исправление текущего коммита, будет скопирован только автор

git commit --amend --no-edit - исправление текущего коммита без вызова редактора

git commit --author='Ded Inside <ded@.com>' --date='4' - коммит с автором и временем

git commit -a --fixup=99659a75 - новый коммит, в описание подставит fixup! + описание
указанного коммита

git branch — показывает список веток

git branch -v — показывает список веток, с информацией о последнем коммите

git branch branch-name — создает новую ветку branch-name

git branch master f7ebf88ca2ce2ea5618a6785127b6a521df1610f - создаём ветку с определённым HEAD коммитом

git branch --force master f7ebf88ca2ce2ea5618a6785127b6a521df1610f - указываем HEAD коммит для существующей ветки,
если без --force, то будет ошибка

git branch --force master testf - указываем HEAD коммит для ветки master, ссылаясь на HEAD коммит ветки testf

git branch -d branch-name — удаляет ветку branch-name, только если она была объеденена с другой веткой

git branch -D branch-name — удаляет ветку branch-name

git branch master 5dadddcd - создаст(вернёт) ветку после удаления, если удаление было недавно

git branch ficha HEAD@{2} - создаст ветку по данным из git reflog

git branch ficha HEAD@{'2022-12-01 17:22:02 +0300'} - создаст ветку по данным из git reflog --date
кавычки из-за пробела

git branch -f ficha ORIG_HEAD - сместить HEAD ветки ficha к предыдущему коммиту(до merge),
который записан в файле ORIG_HEAD

git checkout - Переключается на другую ветку
если есть незакоммиченные и не добавленные в индекс изменения и они отличаются от
ветки на которую переключаемся, то появится предупреждение.
Если при переключении рабочую область менять не нужно, изменения такие же как и
коммит в ветке на которую хотим переключится, и изменения добавлены в индекс,
то переключение осуществится даже с незакомм изменениями. При возвращении в
начальную ветку изменения не сохранятся

git checkout branch-name — переключается на последний коммит в ветке branch-name

git checkout 41a05b43b706e5b6034c27eb2784b1952985063a - переключение на определённый коммит.
Установка HEAD на коммит, не желательно делать коммиты, без ветки

git checkout 0955f3b2 src/ggg.txt - получаем версию файла из определённого коммита

git checkout HEAD -- src/ggg.txt - получить версию файла из HEAD ветки
-- master - обозначение дирректории master, а не ветки

git checkout -b branch-name — создает и переключается на ветку branch-name
в созданной ветке будут также не добавленные изменения из ветки откуда новую создаём.
Если в новой ветке сделаем коммит, все незакомм изменения из первой ветки пропадут

git checkout -b branch-name f7ebf88ca2ce2ea5618a6785127b6a521df1610f - создаёт и переключает
на ветку с HEAD на определённом коммите

git checkout -B master f7ebf88ca2ce2ea5618a6785127b6a521df1610f - если ветка существует
установит HEAD на определённый коммит

git checkout --force branch-name - переключение на ветку branch-name
с удалением незакоммиченных изменений

git checkout --force HEAD - переключение на текущую ветку без сохр изменений
git checkout -f

git checkout @{-1} - перейдёт на ветку с которой был последний checkout из reflog
git checkout -

git checkout -B ficha testf - перенести HEAD ветки в которой находимся на HEAD ветки testf
git branch -f ficha testf - если находимся в ветке которую нужно перенести, то не сработает

git stash - сохранение и удаление незакоммиченных изменений из рабочей дирректории
stash не привязан к ветке, можно восстановить и на другой ветке, но возможны ошибки

git stash pop - восстановление незакоммиченных изменений в рабочую дирректорию

git cherry-pick 469f40dd - добавляет изменения только указанного коммита,
можем взять любой коммит. Будет создан новый коммит

git cherry-pick 469f40dd -n - скопирует изменения коммита и добавит в индекс,
но не будет делать коммит
git cherry-pick 469f40dd --no-commit

git cherry-pick 469f40dd ae9073fb - добавляет изменения нескольких коммитов,
каждый коммит который мы копируем образует новый коммит в ветке куда копируем

git cherry-pick master..ficha - добавляет изменения коммитов ветки ficha которых
не было в ветке master(до разделения)

git cherry-pick master~2..master - копировать в текущую ветку коммиты, начиная с
2 коммита назад от HEAD master до HEAD master

git cherry-pick @~3 -m 1 - копирование изменений коммита слияния,
можем выбрать изменения какого родителя хотим копировать


git cherry-pick --abort - отмена cherry-pick, если копировалось несколько коммитов,
все будут отменены

git cherry-pick --continue - продолжение копирования либо коммит если коммитов
для копирования больше нет

git cherry-pick --quit - сохранить уже скопированные изменения из коммитов,
но отменить копирование оставшихся коммитов


git merge testf — совмещает текущую ветку с branch-name
добавить изменения из ветки testf в текущую ветку. Сместить HEAD текущей ветки на
ветку testf. Добавляет изменения всех коммитов ветки testf

git merge testf - в описание попадут описания сливаемых коммитов

git merge ficha --no-commit - обязательный переход в режим слияния

git merge --no-ff ficha - если для слияния нужно будет просто переставить HEAD
git всё равно проведёт слияние(для ясного разделения веток)
git config merge.ff false - настройка для запрета перемоток для всех merge

git merge --squash ficha - добавление изменений из ficha, без объединения веток
git merge --abort не сработает или reset или commit


В режиме истинного слияния:
git checkout --ours redactor/rrr.txt - выбрать вариант файла из ветки в которую происходит слияние

git checkout --theirs redactor/rrr.txt - выбрать вариант файла из ветки c которой происходит слияние

git checkout --merge redactor/rrr.txt - вернуть файл в режим слияния

git checkout --conflict=diff3 --merge src/ggg.txt - режим слияния файла +
то что было в файле до разделения веток(base)
git config --global merge.conflictStyle diff3 - настроить режим слияния с base по умолчанию

git reset --hard - выход из режима слияния, в HEAD без сохранения изменений других файлов

git reset --merge - выход из режима слияния, удалит изменения из индекса, но оставит
в рабочей директории
git merge --abort

git merge --continue - коммит с вызовом редактора


git merge-base master ficha - общий коммит до разделения веток

git rebase master - перенести текущую ветку на HEAD ветки master

git rebase master vetka - перенести vetka на master

git rebase -x 'команда' master - при окончании каждого слияния будет запускаться
команда, если команда не выполнится, rebase остановится

git rebase --onto master ficha - перенести текущую ветку на master,
начиная с HEAD ветки ficha

git rebase --onto master @~2 - перенести текущую ветку на master,
начиная 2 коммита назад текущей ветки

git rebase --rebase-merges master - переместит вместе с коммитом слияния.
При обычном rebase коммит слияния пропускается. Используется если в ветке
которую нужно перенести есть коммиты слияния


git rebase -i master - интерактивное перемещение. В редакторе можем менять местами,
удалять коммиты

git rebase -i @~3 - интерактивное перебазирование 3 последних коммитов на 4 коммит ветки.
В редакторе можем менять местами, удалять коммиты
--no-ff - обязательное копирование. Если коммит при перебазировании коммит можно не менять,
а оставить, то по умолчанию новый коммит создан не будет, а оставлен уже имеющийся.
С этим флагом будет выполнено обязательное копирование

Commands:
p, pick <commit> = копировать коммит
r, reword <commit> =  копировать коммит, но изменить сообщение(описание) коммита
e, edit <commit> = после копирования остановится и даст возможность редактировать коммит
s, squash <commit> = объединить с предыдущим коммитом, не может быть первым
f, fixup [-C | -c] <commit> = объединить с предыдущим и откинуть описание
x, exec <command> = добавить команды, после каждого коммита будут выполняться команды,
если команда не выполнится, rebase остановится(git rebase -x 'команда' master)
# b, break = stop here (continue rebase later with 'git rebase --continue')
d, drop <commit> = пропустить коммит
# l, label <label> = label current HEAD with a name
# t, reset <label> = reset HEAD to a label
# m, merge [-C <commit> | -c <commit>] <label> [# <oneline>]
# .       create a merge commit using the original merge commit's
# .       message (or the oneline, if no original merge commit was
# .       specified); use -c <commit> to reword the commit message

git rebase --edit-todo - посмотреть и поправить список запланированных действий

git rebase -i --autosquash - автоматически подставит коммит сделанный командой
git commit -a --fixup=99659a75 после коммита(99659a75), подставлять будет по
схожему описанию после слова fixup!. Также в интерактиве поставит команду fixup
для объединения в один коммит с откидыванием описания коммита у которого fixup

git config --global rebase.autoSquash true - автоматический autoSquash для всех git rebase -i


В режиме слияния: (git reset --hard не работает для выхода, только очищает)

git rebase --abort - прекратит rebase

git rebase --quit - остановимся на последнем удачно разрешенном слиянии

git rebase --skip - пропуск коммита

git rebase --continue - продолжить rebase


git revert @ - создаёт новый коммит обратный коммиту(добавленные строки удалятся)

git revert @ -m 1 - отмена коммита слияния, создаёт новый коммит обратный коммиту.
у коммита слияния 2 родителя, нужно выбрать того чьи изменения оборачивать.
Если мы обращали изменения слияния, то в будущем при слиянии коммиты изменения которых
мы обратили в новом коммите, не будут затронуты, они уже есть в ветке, хоть и обращены в новом коммите.
Слияние произойдёт только с новыми коммитами ветки, которую объединяли в прошлом.
Решение: обратить ранее обращённый коммит, изменения которые мы отменили вернутся
или
копируем отменённые коммиты с помощью git cherry-pick
или
использовать git rebase --onto - перебазировать ветку для будущего слияния
(все коммиты побочной ветки перебазируются, без onto не все)
или
git rebase 54a5 --no-ff - на тот же коммит из которого ветка началась,
флаг позволяет обязательно копировать, даже те же коммиты на то же место
(для избавления от прошлого слияния с ошибкой, в новой ветке слияния не будет)

git revert A..B - создаёт новые обратные коммиты от A(без A) по B(включая B)

git diff - сравнивает рабочую директорию с индексом (игнорирует не отслеживаемые файлы!)

git diff HEAD - сравнивает рабочую директорию с HEAD коммитом

git diff --staged - сравнивает индекс с HEAD коммитом
git diff --cached

git diff -- src/ggg.txt - просмотр изменений файла с изменениями в индексе

git diff ficha master - сравнивает изменения в ветках
git diff ficha..master

git diff master...ficha - что изменилось в ветке ficha, после того как она отделилась от ветки master.
сравнение коммита до отделения ficha от master с HEAD коммитом ficha

git diff ficha...master - сравнение коммита до отделения ficha от master с HEAD коммитом master

git diff bd4f7852 - сравнение рабочей директории с коммитом

git diff --name-only master ficha - файлы в которых есть различия между ветками

git config - Конфигурация и параметры git

git config --global user.name — Показывает имя пользователя

git config --global user.name 'new user' — Изменяет имя пользователя

git config --global user.email — Показывает email пользователя

git config --global user.email 'test@mail.ru' — Изменяет email пользователя

git push - Заливает текущие локальные коммиты в удаленный репозиторий

git pull - Забирает изменения с удаленного репозитория в локальный

git clone - Клонирует проект с удаленного репозитория

git push --set-upstream origin ‘name’        заливает побочную ветку

